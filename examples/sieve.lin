\SIEVE :: { 1 1: }.\s ;
"n:"out in 1+.\n SIEVE ;
1 .n.-> ( .s.+_ g: \\_ e& ).' ;
10cols.$$ m>s outln

#SIEVE ; clr
  .n .5^ 0| 1 .-> (.\a .s .a g: \; e| ).'
    $` ( 2+ .a * ) `' ( .n <= ) `t' ( .s 1 .@ :.\s ) `' `_



# EXPLANATION

Outputs a Sieve of Eratosthenes.

- `\n: out in 1+ .\n` stores input + 1 to *n*.
- `{ 1 1: }.\s SIEVE clr` initializes the sieve, runs SIEVE, and clears the stack.
- `1 .n range (...) map` for each item *b* in the range from 1 to *n*...
  - `.s over g: \\_ e&` replaces sieved (i.e. non-prime) numbers with `_`.
- `( 0absb ( ns len ).' max.\m ) 1's ( \ .m pad ).' ;` pads each element with spaces.
- `10cols \<ws.'.$$ <ls outln` formats and outputs the stack.

In SIEVE:

- `.n .5^ 0| 1 range` creates a range from `floor(sqrt(n))` to 1.
- `(.\a...) map` for each item *a* in the range...
  - `.s .a g: \; e|` executes line 6 if *a* isn't found in the sieve.

On line 6:

- `$\` ( 2+ .a * ) `'` generates an infinite list of multiples of *a*.
- `( .n <= ) \`t'` takes list elements that are <= *n*.
- `( .s 1 rot :.\s ) `' `_` puts each element into the sieve.