( (I.lambda=1,I.scope.unshift({}))
) {}
[ (I.iter.unshift(I.st),I.stack[I.st=I.iter[0]+'\n']=[])
] (X=I.stack[I.st],delete I.stack[I.iter[0]+'\n'],I.st=I.iter.shift(),I.unshift(X))
{ (I.objs.unshift({}),I.iter.unshift(I.st),I.stack[I.st=I.iter[0]+'\n']=[])
} (X=I.objs.shift(),delete I.stack[I.iter[0]+'\n'],I.st=I.iter.shift(),I.unshift(X))
() I.unshift('') //push empty string
[] I.unshift([]) //initialize empty list
{} I.unshift({}) //initialize empty list
\\ I.unshift(' ') //push space
n\\ I.unshift('\n') //push newline

gi I.unshift(I.ids[I.shift()]) //push string at ID given by index 0
gi\\ I.unshift(unesc(I.ids[I.shift()])) //`gi` but parse escape codes
gl I.unshift(I.getscope())
gl\\ I.unshift(unesc(I.getscope()))
gs I.unshift(I.form()) //push stack joined by newlines
g@ I.unshift(I.lines[I.shift()]) //push line at popped number (0-indexed)
g: (X=I.shift(),I.unshift(I.shift()[X])) //get value for key given by index 0 within object at index 1
form I.unshift(I.form([I.shift()]))
si I.ids[I.shift()]=I.shift() //set global ID at index 0
sl (X=I.shift(),Y=I.shift(),I.scope.length?(I.scope[0][X]=Y):(I.ids[X]=Y))
: I.objs.length?(I.objs[0][I.shift()]=I.shift()):(X=I.shift(),Y=I.shift(),I.stack[I.st][0][X]=Y) //set a key-value pair in an object, where index 0 is the key and index 1 is the value
:: I.id() //`gi` without pushing anything to stack (used for exposing ID's cleanly)
type (X=I.shift(),I.unshift(X.pop?3:X.big?2:X.toFixed&&!isNaN(X)?1:0)) //pushes 1 if index 0 is a number, 2 if string, 3 if list, and 0 if anything else (ex.: undefined)

es I.exec(I.shift(),1) //execute string at index 0
e* (i=I.shift(),j=I.shift(),addf(a=>(i&&(addf(a=>I.unshift(i-1,j),'e*'),I.exec(j,1))))) //`es` on index 1 for number of times given by index 0
e& (SL.swap(),I.shift()?SL.es():I.shift()) //`es` if index 1 is truthy
e| (SL.swap(),I.shift()?I.shift():SL.es()) //`es` if index 1 is falsy
e? (SL.rot(),I.shift()||SL.swap(),I.shift(),SL.es()) //`es` on index 1 if index 2 is truthy; otherwise, `es` on index 0
ew (i=I.shift(),j=I.shift(),addf(a=>(I.shift()&&(addf(a=>I.unshift(i,j),'ew'),I.exec(i,1)))),I.exec(j,1)) //while `es` on index 1 is truthy, `es` on index 0
; (I.lns.unshift(I.lns[0]+1),I.code[0].length&&addf(a=>I.lns.shift()),I.exec(I.lines[I.lns[0]],1)) // `es` next line
;; (I.lns.unshift(I.lns[0]-1),I.code[0].length&&addf(a=>I.lns.shift()),I.exec(I.lines[I.lns[0]],1)) // `es` previous line
stop I.code.shift() //end execution of current call stack frame

read I.unshift(fs.readFileSync(I.shift())+'') //read file at path given by index 0
write fs.writeFileSync(I.shift(),I.shift()) //write string at index 1 to file at path given by index 0
in I.unshift((''+cp.execSync('read x;echo $x',{stdio:[process.stdin]})).slice(0,-1)) //push user input
inh I.unshift((''+cp.execSync('read -s x;echo $x',{stdio:[process.stdin]})).slice(0,-1)) //push user input without echoing
out process.stdout.write(''+I.shift()) //output index 0 to STDOUT
outln process.stdout.write(''+I.shift()+'\n') //output index 0 as a line to STDOUT

$E I.unshift(Math.E) //Euler's constant
$Pi I.unshift(Math.PI) //π

E (SL.swap(),I.unshift(I.shift()*Math.pow(10,I.shift()))) //`(index 1)*10^(index 0)`
_ I.unshift(-I.shift()) //negation
+ I.unshift(I.shift()- -I.shift()) //addition
- (SL.swap(),I.unshift(I.shift()-I.shift())) //subtraction
* I.unshift(I.shift()*I.shift()) //multiplication
/ (SL.swap(),I.unshift(I.shift()/I.shift())) //division
// (SL.swap(),I.unshift(Math.floor(I.shift()/I.shift()))) //integer division
% (SL.swap(),I.unshift(I.mod(I.shift(),I.shift()))) //modulus
/% (SL.over(),SL.over(),$['//'](),SL.rot_(),$['%']()) //divmod
^ (SL.swap(),I.unshift(Math.pow(I.shift(),I.shift()))) //exponentiation
abs I.unshift(Math.abs(I.shift())) //absolute value
sign I.unshift(Math.sign(I.shift())) //sign function
rand I.unshift(Math.random()) //push random number between 0 and 1
time I.unshift(_.now()) //push milliseconds since January 1, 1970 00:00:00.000
ln I.unshift(Math.log(I.shift())) //natural logarithm
log I.unshift(Math.log10(I.shift())) //base-10 logarithm
sin I.unshift(Math.sin(I.shift())) //sine
cos I.unshift(Math.cos(I.shift())) //cosine
tan I.unshift(Math.tan(I.shift())) //tangent
sinh I.unshift(Math.sinh(I.shift())) //hyperbolic sine
cosh I.unshift(Math.cosh(I.shift())) //hyperbolic cosine
tanh I.unshift(Math.tanh(I.shift())) //hyperbolic tangent
asin I.unshift(Math.asin(I.shift())) //inverse sine
acos I.unshift(Math.acos(I.shift())) //inverse cosine
atan I.unshift(Math.atan(I.shift())) //inverse tangent
asinh I.unshift(Math.asinh(I.shift())) //inverse hyperbolic sine
acosh I.unshift(Math.acosh(I.shift())) //inverse hyperbolic cosine
atanh I.unshift(Math.atanh(I.shift())) //inverse hyperbolic tangent
max I.unshift(Math.max(...I.stack[I.st])) //push max
min I.unshift(Math.min(...I.stack[I.st])) //push min
range (i=I.shift(),j=I.shift(),I.unshift(...I.range(j,i).reverse())) //inclusive range

~ I.unshift(~I.shift()) //bitwise not
! I.unshift(+!I.shift()) //logical not
& I.unshift(I.shift()&I.shift()) //bitwise and
| I.unshift(I.shift()|I.shift()) //bitwise or
$ I.unshift(I.shift()^I.shift()) //bitwise xor
<< (SL.swap(),I.unshift(I.shift()<<I.shift())) //bitwise left shift
>> (SL.swap(),I.unshift(I.shift()>>I.shift())) //bitwise right I.shift, sign-propagating
>>> (SL.swap(),I.unshift(I.shift()>>>I.shift())) //bitwise right I.shift, zero-fill

= I.unshift(+(I.shift()==I.shift())) //equal
!= I.unshift(+(I.shift()!=I.shift())) //not equal
> I.unshift(+(I.shift()<I.shift())) //greater than
< I.unshift(+(I.shift()>I.shift())) //less than
>= I.unshift(+(I.shift()<=I.shift())) //greater than or equal to
<= I.unshift(+(I.shift()>=I.shift())) //less than or equal to
<=> (i=I.shift(),j=I.shift(),I.unshift(i<j?1:i>j?-1:0)) //comparison function (-1 for less than, 0 for equal, 1 for greater than)

floor I.unshift(Math.floor(I.shift())) //round towards -∞
trunc I.unshift(Math.trunc(I.shift())) //round towards 0
round I.unshift(Math.round(I.shift())) //round towards or away from 0 depending on < or >= .5
ceil I.unshift(Math.ceil(I.shift())) //round towards ∞

pick I.unshift(I.get(I.shift())) //`dup` but with any index
nix I.splice(I.shift()) //`drop` but with any index
roll (x=I.get(0),SL.pick(),I.unshift(x+1),SL.nix()) //`rot` but with any index
roll_ I.splice(I.shift(),0,I.shift()) //`rot_` but with any index
trade I.unshift(I.splice(I.shift()-1,1,I.shift())[0]) //swap index 1 with index given by index 0
dup I.unshift(I.stack[I.st][0]) //push index 0
drop I.shift() //pop index 0
rot I.unshift(I.splice(2)[0]) //bring index 2 to index 0
rot_ (SL.rot(),SL.rot()) //bring index 0 to index 2
swap I.unshift(I.splice(1)[0]) //bring index 1 to index 0
nip (SL.swap(),I.shift()) //pop index 1
tuck (SL.dup(),SL.rot_()) //push index 0 to index 2
over (SL.swap(),SL.tuck()) //push index 1
clr I.stack[I.st]=[] //pop all items
rev I.stack[I.st].reverse() //reverse stack
dip (SL.swap(),i=I.shift(),addf(a=>I.unshift(i)),I.exec(I.shift(),1)) //pop index 0, `es`, push popped index 0

split (SL.swap(),I.unshift(...(I.shift()+'').split(I.shift()).reverse())) //split string at index 1 over string at index 0
join (i=I.shift(),I.unshift(I.stack[I.st].slice(0).reverse().join(i))) //join stack over string at index 0
++ I.unshift(I.concat(I.shift(),I.shift())) //concatenate top 2 items as strings or lists
len (X=I.shift(),I.unshift(X.toFixed?(X+'').length:X.length)) //push string length of index 0
>char I.unshift(String.fromCodePoint(I.shift())) //convert number to Unicode
<char I.unshift(I.shift().codePointAt()) //convert Unicode to number
lower I.unshift(I.shift().toLowerCase()) //lowercase
upper I.unshift(I.shift().toUpperCase()) //uppercase
repeat (SL.swap(),I.unshift((I.shift()+'').repeat(I.shift()))) //repeat string by index 0
pad (i=I.shift(),j=I.shift(),k=I.shift(),I.unshift(_.pad(k,j,i))) //pad string given by index 2 until length given by index 0 with string given by index 1
padl (i=I.shift(),j=I.shift(),k=I.shift(),I.unshift(_.padStart(k,j,i))) //`pad` but only from the left
padr (i=I.shift(),j=I.shift(),k=I.shift(),I.unshift(_.padEnd(k,j,i))) //`pad` but only from the right

stack (I.iter.unshift(I.st),X=I.shift(),Y=I.shift(),I.stack[I.st=X]||(I.stack[I.st]=[]),I.addf(a=>I.st=I.iter.shift()),I.exec(Y,1)) //execute string given by index 1 on a stack with name given by index 0
push I.stack[I.shift()].unshift(I.shift()) //push index 1 to another stack with name given by index 0
pull I.unshift(I.stack[I.shift()].shift()) //push top item of another stack with name given by index 0
size I.unshift(I.stack[I.st].length) //push stack length
uniq I.stack[I.st]=_.uniq(I.stack[I.st]) //remove all duplicates in current stack
take I.stack[I.st]=_.take(I.stack[I.st],I.shift()) //keep top _n_ items, where _n_ is index 0
drop I.stack[I.st]=_.drop(I.stack[I.st],I.shift()) //pop top _n_ items, where _n_ is index 0
merge I.unshift(...I.stack[I.shift()]) //push items of another stack with name given by index 0
union (i=I.shift(),I.stack[I.st]=_.union(I.stack[I.st],I.stack[i])) //set union with current stack and stack with name given by index 0
intersection (i=I.shift(),I.stack[I.st]=_.intersection(I.stack[I.st],I.stack[i])) //set intersection with current stack and stack with name given by index 0
difference (i=I.shift(),I.stack[I.st]=_.difference(I.stack[I.st],I.stack[i])) //set difference with current stack and stack with name given by index 0
wrap I.unshift([I.shift()]) //wrap index 0 in a list
wrap_ (X=I.shift(),I.unshift(...X.pop?X:[X])) //opposite of `wrap`; take all items in list at index 0 and push to parent stack
enclose I.unshift(I.stack[I.st].slice(0)) //push entire stack as a list
usurp I.stack[I.st]=[...shift()] //set current stack to the list at index 0
' (X=I.shift(),Y=I.shift(),Y=Y.big?Y.split``:Y.toFixed?(Y+'').split``:Y,I.iter.unshift(I.st), //apply function to list given by index 0
    I.stack[I.st=I.iter[0]+'\n']=Y,
    I.addf(a=>(Y=I.stack[I.st],delete I.stack[I.iter[0]+'\n'],I.st=I.iter.shift(),I.unshift(Y))),I.exec(X,1))
flat I.stack[I.st]=_.flatten(I.stack[I.st]) //`wrap_` all elements
chunk I.stack[I.st]=(X=I.shift(),_.chunk(I.stack[I.st],X)) //split stack into lists of length given by index 0
keys I.unshift(Object.keys(I.shift())) //get keys of object/list at index 0
vals I.unshift(Object.values(I.shift())) //get values of object/list at index 0
enum I.stack[I.st]=I.stack[I.st].map((a,b)=>[b,a]) //convert each item in stack to a list containing index and item
enom I.unshift(Object.keys(X=I.shift()).map(a=>[X[a],a])) //convert each item in stack to a list containing index and item
del delete I.stack[I.st][1][I.shift()]

map (X=I.shift(),I.iter.unshift(I.st), //`es` on each individual item in the stack
  I.addf(a=>(delete I.stack[I.iter[0]+' '],I.st=I.iter.shift())),
  I.stack[I.st].map((a,b)=>
    I.addf(A=>I.stack[I.st=I.iter[0]+' ']=[a],...I.parse(X),A=>I.stack[I.iter[0]][b]=I.shift())
  ))
fold (X=I.shift(),Z=I.shift(),I.iter.unshift(I.st), //`es` with accumulator and item; result of each `es` becomes the new accumulator
  I.addf(a=>(delete I.stack[I.iter[0]+' '],I.stack[I.st=I.iter.shift()]=[Z])),
  I.stack[I.st].map(a=>
    I.addf(A=>I.stack[I.st=I.iter[0]+' ']=[a,Z],...I.parse(X),A=>Z=I.shift())
  ))

filter (I.addf(a=>I.stack[I.st]=I.stack[I.st].filter(a=>a)),SL.map()) //remove each item that is falsy after `es`
any (I.addf(a=>I.stack[I.st]=[+I.stack[I.st].some(a=>a)]),SL.map()) //push 1 if any items return truthy after `es`, else push 0
all (I.addf(a=>I.stack[I.st]=[+I.stack[I.st].every(a=>a)]),SL.map()) //push 1 if all items return truthy after `es`, else push 0
find (I.addf(a=>I.stack[I.st]=[I.stack[I.st].find(a=>a)]),SL.map()) //find first item that returns truthy after `es` or undefined on failure
findi (I.addf(a=>I.stack[I.st]=[I.stack[I.st].findIndex(a=>a)]),SL.map()) //`find` but returns index (or -1 on fail)
takew (I.addf(a=>I.stack[I.st]=_.takeWhile(I.stack[I.st])),SL.map()) //`take` items until `es` returns falsy for an item
dropw (I.addf(a=>I.stack[I.st]=_.dropWhile(I.stack[I.st])),SL.map()) //`drop` items until `es` returns falsy for an item
sort (I.addf(a=>I.stack[I.st]=_.sortBy(I.stack[I.st]).reverse()),SL.map()) //sort items in ascending order based on `es`
part (I.addf(a=>I.stack[I.st]=_.partition(I.stack[I.st])),SL.map()) //separate items into 2 lists based on whether they return truthy after `es`
